<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Doodle Jump Mini</title>
  <style>
    body { margin: 0; display: grid; place-items: center; height: 100vh; background: #111; }
    canvas { background: #F6F7FB; border-radius: 12px; }
    .overlay {
      position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      flex-direction:column; gap:12px; color:#fff; font-family: system-ui, Arial;
    }
    .wrap { position: relative; }
    button { padding: 10px 14px; font-weight: 700; cursor: pointer; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="420" height="640"></canvas>
    <div id="ov" class="overlay">
      <div style="font-size:28px;font-weight:800;">GAME OVER</div>
      <div id="scoreText" style="font-size:18px;"></div>
      <button id="again">Try Again</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const ov = document.getElementById("ov");
  const scoreText = document.getElementById("scoreText");
  const again = document.getElementById("again");

  const W = canvas.width, H = canvas.height;
  const FPS = 60, DT = 1 / FPS;

  const GRAVITY = 1800;
  const JUMP_VY = -700;
  const MOVE_SPEED = 320;
  const SCROLL_LINE = H * 0.40;

  const PLATFORM_W = 70, PLATFORM_H = 12;
  const GAP_MIN = 55, GAP_MAX = 95;

  const PLAYER_W = 26, PLAYER_H = 30;

  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    keys.add(e.key);
    if (gameOver && (e.key === "Enter" || e.key === " ")) reset();
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key));

  function randInt(a,b){ return (Math.random()*(b-a+1) + a) | 0; }

  let px, py, vx, vy, platforms, cameraY, score, gameOver;

  function addPlatform(cx, cy) {
    platforms.push({ x: cx - PLATFORM_W/2, y: cy - PLATFORM_H/2, w: PLATFORM_W, h: PLATFORM_H });
  }

  function reset() {
    ov.style.display = "none";
    gameOver = false;
    score = 0;
    cameraY = 0;

    px = W/2; py = H*0.70;
    vx = 0; vy = -200;

    platforms = [];
    addPlatform(W/2, H*0.80);
    let y = H*0.70;
    for (let i=0;i<10;i++){
      y -= randInt(GAP_MIN, GAP_MAX);
      addPlatform(randInt(PLATFORM_W/2, W-PLATFORM_W/2), y);
    }
  }

  function wrapX() {
    if (px < -PLAYER_W/2) px = W + PLAYER_W/2;
    else if (px > W + PLAYER_W/2) px = -PLAYER_W/2;
  }

  function checkCollisions(oldPy) {
    if (vy <= 0) return;
    const px0 = px - PLAYER_W/2, px1 = px + PLAYER_W/2;
    const py1 = py + PLAYER_H/2;
    const oldPy1 = oldPy + PLAYER_H/2;

    for (const p of platforms) {
      const x0 = p.x, x1 = p.x + p.w, y0 = p.y, y1 = p.y + p.h;
      if (px1 <= x0 || px0 >= x1) continue;
      if (oldPy1 <= y0 && py1 >= y0 && py1 <= y1 + 8) {
        py = y0 - PLAYER_H/2;
        vy = JUMP_VY;
        break;
      }
    }
  }

  function recyclePlatforms() {
    platforms = platforms.filter(p => p.y < H + 80);
    while (platforms.length < 12) {
      let topY = platforms.reduce((m,p)=>Math.min(m,p.y), H);
      let newY = topY - randInt(GAP_MIN, GAP_MAX);
      let newX = randInt(PLATFORM_W/2, W-PLATFORM_W/2);
      addPlatform(newX, newY);
    }
  }

  function endGame() {
    gameOver = true;
    scoreText.textContent = `Score: ${score}`;
    ov.style.display = "flex";
  }

  again.addEventListener("click", reset);

  function update() {
    if (gameOver) return;

    const left = keys.has("ArrowLeft") || keys.has("a") || keys.has("A");
    const right = keys.has("ArrowRight") || keys.has("d") || keys.has("D");
    vx = left && !right ? -MOVE_SPEED : right && !left ? MOVE_SPEED : 0;

    vy += GRAVITY * DT;
    const oldPy = py;
    px += vx * DT;
    py += vy * DT;

    wrapX();
    checkCollisions(oldPy);

    if (py < SCROLL_LINE) {
      const dy = SCROLL_LINE - py;
      py = SCROLL_LINE;
      cameraY += dy;
      for (const p of platforms) p.y += dy;
      score = Math.max(score, cameraY | 0);
      recyclePlatforms();
    }

    if (py - PLAYER_H/2 > H) endGame();
  }

  function draw() {
    ctx.clearRect(0,0,W,H);

    // platforms
    for (const p of platforms) {
      ctx.fillStyle = "#2ECC71";
      ctx.fillRect(p.x, p.y, p.w, p.h);
      ctx.strokeStyle = "#1E9E52";
      ctx.strokeRect(p.x, p.y, p.w, p.h);
    }

    // player
    ctx.fillStyle = "#3498DB";
    ctx.beginPath();
    ctx.ellipse(px, py, PLAYER_W/2, PLAYER_H/2, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "#1F6FA3";
    ctx.stroke();

    // eyes
    ctx.fillStyle = "white";
    ctx.beginPath(); ctx.ellipse(px-4, py-4, 2, 2, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(px+4, py-4, 2, 2, 0, 0, Math.PI*2); ctx.fill();

    // score
    ctx.fillStyle = "#111";
    ctx.font = "bold 14px system-ui, Arial";
    ctx.fillText(`Score: ${score}`, 10, 20);
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  reset();
  loop();
})();
</script>
</body>
</html>
